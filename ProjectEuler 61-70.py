# -*- coding: utf-8 -*-
"""
Created on Sat Aug 14 18:39:52 2021

@author: catal
"""

import pdb
import math
import timeit
from functools import reduce
from itertools import count, islice
import itertools
import string
import regex as re
import icecream

"""
problem 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P(3,n)=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	P(4,n)=n2	 	1, 4, 9, 16, 25, ...
Pentagonal	 	P(5,n)=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P(6,n)=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P(7,n)=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P(8,n)=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281,
has three interesting properties.

The set is cyclic, in that the last two digits of each number is
the first two digits of the next number (including the last number with the first).
Each polygonal type:
    triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers
for which each polygonal type:
    triangle, square, pentagonal, hexagonal, heptagonal, and octagonal,
is represented by a different number in the set.
"""

# Goal= sum of set of 6 nums that are:
#     4 digits
#     cyclic
#     triangle, square, pentagonal, hexagonal, heptagonal, and octagonal


def generateTriangleNums(lower_limit, upper_limit):
    """asssumes lower limits and upper_limit are ints,
    the lowest and highest values (inclusive) to be considered
    returns a list of ints, the triangle numbers between lower_limit and upper_limit,
    in acending order
    """
    triangle_num_list = []
    i = int(lower_limit**0.5)
    triangle_num = 1
    while triangle_num <= upper_limit:
        if triangle_num >= lower_limit:
            triangle_num_list.append(triangle_num)
        triangle_num = int(i*(i+1)/2)
        i += 1
    return triangle_num_list


# generateTriangleNums(20, 100)


def generateSquareNums(lower_limit, upper_limit):
    """asssumes lower limits and upper_limit are ints,
    the lowest and highest values (inclusive) to be considered
    returns a list of ints, the square numbers between lower_limit and upper_limit,
    in acending order
    """
    square_num_list = []
    i = int(lower_limit**0.5)
    square_num = 0
    while square_num <= upper_limit:
        if square_num >= lower_limit:
            square_num_list.append(square_num)
        square_num = int(i**2)
        i += 1
    return square_num_list


# print(generateSquareNums(1, 100))
# print(generateSquareNums(44, 100))


def generatePentagonNums(lower_limit, upper_limit):
    """asssumes lower limits and upper_limit are ints,
    the lowest and highest values (inclusive) to be considered
    returns a list of ints, the pentagon numbers between lower_limit and upper_limit,
    in acending order
    """
    pentagon_num_list = []
    i = int(lower_limit**0.5)
    pentagon_num = 0
    while pentagon_num <= upper_limit:
        if pentagon_num >= lower_limit:
            pentagon_num_list.append(pentagon_num)
        pentagon_num = int(i*((3*i)-1)/2)
        i += 1
    return pentagon_num_list


# print(generatePentagonNums(1, 100))
# print(generatePentagonNums(17, 200))


def generateHexagonNums(lower_limit, upper_limit):
    """asssumes lower limits and upper_limit are ints,
    the lowest and highest values (inclusive) to be considered
    returns a list of ints, the hexagon numbers between lower_limit and upper_limit,
    in acending order
    """
    hexagon_num_list = []
    i = int(lower_limit**0.5)
    hexagon_num = 0
    while hexagon_num <= upper_limit:
        if hexagon_num >= lower_limit:
            hexagon_num_list.append(hexagon_num)
        hexagon_num = int(i*((2*i)-1))
        i += 1
    return hexagon_num_list


# print(generateHexagonNums(1,100))


def generateHeptagonNums(lower_limit, upper_limit):
    """asssumes lower limits and upper_limit are ints,
    the lowest and highest values (inclusive) to be considered
    returns a list of ints, the heptagon numbers between lower_limit and upper_limit,
    in acending order
    """
    heptagon_num_list = []
    i = int(lower_limit**0.5)
    heptagon_num = 0
    while heptagon_num <= upper_limit:
        if heptagon_num >= lower_limit:
            heptagon_num_list.append(heptagon_num)
        heptagon_num = int(i*((5*i)-3)/2)
        i += 1
    return heptagon_num_list


# print(generateHeptagonNums(1, 100))
# print(generateHeptagonNums(1000, 10000))


def generateOctagonNums(lower_limit, upper_limit):
    """asssumes lower limits and upper_limit are ints,
    the lowest and highest values (inclusive) to be considered
    returns a list of ints, the octagon numbers between lower_limit and upper_limit,
    in acending order
    """
    octagon_num_list = []
    i = int(lower_limit**0.5)
    octagon_num = 0
    while octagon_num <= upper_limit:
        if octagon_num >= lower_limit:
            octagon_num_list.append(octagon_num)
        octagon_num = int(i*((3*i)-2))
        i += 1
    return octagon_num_list


# print(generateOctagonNums(1, 100))


def isCyclic2Digit(num1, num2):
    """assumes num1 and num2 are ints
    returns True if the last 2 digits of num1 are the same as the first 2 digits of num2,
    else returns False
    """
    return (str(num1)[-2] + str(num1)[-1]) == str(num2)[:2]


# print(isCyclic2Digit(1994, 9433))

def get_permutations(sequence):
    '''
    Assumes sequence is an arbitrary string and non-empty
    Returns: a list of strings, all the permutations of sequence
    Example: get_permutations('abc')
    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
    note: do not depend on order of the output list
    '''
    permutations_of_sequence = []
    permutations_of_cutdown_sequence = []
    # define recursive behaviour
    # for sequence of len(n), case is sequence[0] and sequence[1:n]
    if len(sequence) > 1:
        first_char_sequence = sequence[0]
        cutdown_sequence = sequence[1:]
        # find recursions of cutdown_sequence
        if len(cutdown_sequence) > 1:
            permutations_of_cutdown_sequence = get_permutations(sequence[1:])
        # base case
        # add first_char_sequence to all recursions of cutdown_sequence
        for i in range(len(sequence)):
            holding_string = cutdown_sequence[:i] + first_char_sequence + cutdown_sequence[i:]
            permutations_of_sequence += [holding_string]
        # loop over each item in permutations_of_cutdown_sequence
        if len(permutations_of_cutdown_sequence) > 1:
            for ele in range(len(permutations_of_cutdown_sequence)):
                new_cutdown_sequence = permutations_of_cutdown_sequence[ele]
                for i in range(len(sequence)):
                    holding_string = new_cutdown_sequence[:i] + first_char_sequence + new_cutdown_sequence[i:]
                    permutations_of_sequence += [holding_string]
    # remove duplicates from permutations_of_sequence
    return list(dict.fromkeys(permutations_of_sequence))


def cyclicalFigurateNums():
    """returns an int, the sum of the set of 6 numbers where the numbers are:
        cyclic
        4 digits
        each is a polygonal number from triangle to octagon
    """
    # initialize lists of 4 digit polygon numbers
    triangle_nums_list = generateTriangleNums(1000, 10000)
    square_nums_list = generateSquareNums(1000, 10000)
    pentagon_num_list = generatePentagonNums(1000, 10000)
    hexagon_num_list = generateHexagonNums(1000, 10000)
    heptagon_num_list = generateHeptagonNums(1000, 10000)
    octagon_num_list = generateOctagonNums(1000, 10000)
    polygon_nums_list_list = [triangle_nums_list, square_nums_list, pentagon_num_list,
                              hexagon_num_list, heptagon_num_list, octagon_num_list]
    # permutations of polygon lists
    polygon_permutations = get_permutations("012345")  # list of permutations
    # generate list
    pdb.set_trace()
    for permutation in polygon_permutations:
        reordered_polygon_nums_list_list = []
        for digit in permutation:
            reordered_polygon_nums_list_list.append(polygon_nums_list_list[int(digit)])

    # test for cyclic  on each polygon list
    # TODO change syntax to work with list of lists
    # for triangle_num in triangle_nums_list:
    #     triangle_num_start = int((str(triangle_num)[:2]))
    #     triangle_num_end = int((str(triangle_num)[2:]))
    #     for square_num in square_nums_list:
    #         square_num_start = int((str(square_num)[:2]))
    #         square_num_end = int((str(square_num)[2:]))
    #         if triangle_num_end == square_num_start:
    #             for pentagon_num in pentagon_num_list:
    #                 pentagon_num_start = int((str(pentagon_num)[:2]))
    #                 pentagon_num_end = int((str(pentagon_num)[2:]))
    #                 if square_num_end == pentagon_num_start:
    #                     for hexagon_num in hexagon_num_list:
    #                         hexagon_num_start = int((str(hexagon_num)[:2]))
    #                         hexagon_num_end = int((str(hexagon_num)[2:]))
    #                         if pentagon_num_end == hexagon_num_start:
    #                             for heptagon_num in heptagon_num_list:
    #                                 heptagon_num_start = int((str(heptagon_num)[:2]))
    #                                 heptagon_num_end = int((str(heptagon_num)[2:]))
    #                                 if hexagon_num_end == heptagon_num_start:
    #                                     for octagon_num in octagon_num_list:
    #                                         octagon_num_start = int((str(octagon_num)[:2]))
    #                                         octagon_num_end = int((str(octagon_num)[2:]))
    #                                         if heptagon_num_end == octagon_num_start and octagon_num_end == triangle_num_start:
    #                                             print(triangle_num, square_num, pentagon_num, hexagon_num, heptagon_num)
    pdb.set_trace()
    print("kittens")

print(cyclicalFigurateNums())

# # take 6 lists in any order = 720 permutations.

# outer loop = take any order of lists

# inner loops = test all posibilities for lists in that order
